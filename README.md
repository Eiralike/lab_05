# lab_05
Скопируем уязвимый код и скомпилируем в формате 32-битного приложения.
int main(int argc, char *argv[]) принимает на вход программы какой-то аргумент, затем printf(argv[1]) выводит его в консоль. Если передать %x на вход программы, но не передать сам аргумент для функции printf, то она будет читать из данные из стека, в котором как раз находится пароль из файла .passwd, потому что он был записан в буферную переменную: fgets(buffer, sizeof(buffer), secret);


с помощью скрипта постепенно передаём от 1 до 40 аргументов %x для функции main программы на вход и видим, что выводятся данные в hex:\
for i in $(seq 1 40); do python3 -c "print(\"%x-\"*$i)" | xargs ./main 2>/dev/null; echo ""; done 



![](/Screenshot%20from%202024-12-18%2000-24-30.png)

### При переводе из hex увидим как раз пароль, который находится в файле .passwd 
![](/Screenshot%20from%202024-12-18%2000-29-44.png)
только пароль перевернут из-за обратного чтения битов